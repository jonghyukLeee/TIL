# 오늘 배운점

---

# Dockerfile

### 컨테이너 생성과 커밋

- build 명령어는 Dockerfile에 기록된 대로 컨테이너를 실행한 뒤 완성 이미지를 만든다. 하지만, 이 과정이 하나의 컨테이너에서 일어나는 것은 아니다.
- 명령어 한줄이 실행되는 매 Step마다, 새로운 컨테이너가 하나 씩 생성되며, 이를 이미지로 커밋한다.
즉, Dockerfile에서 명령어 한 줄이 실행될 때 마다 이전 Step에서 생성된 이미지에 의해 새로운 컨테이너가 생성되며, Dockerfile에 적힌 명령어를 수행하고 다시 새로운 이미지 레이어로 저장된다.
따라서, 이미지 빌드가 완료되면 명령어 줄 수만큼의 레이어가 존재하게 되며, 중간에 컨테이너도 같은 수만큼 생성되고 삭제된다.

### 캐시를 이용한 이미지 빌드

- 한 번 이미지 빌드를 마치고 난 뒤 다시 같은 빌드를 진행하면 캐시를 사용함
- 새로 빌드하지 않고 같은 명령어 줄 까지 이전에 사용한 이미지 레이어를 활용해 이미지를 생성
- 불필요할 경우 build 명령어에 —no-cache 옵션 추가

### 멀티 스테이지

- 하나의 Dockerfile안에 여러 개의 FROM 이미지를 정의하는 것
- 빌드 완료 시 생성될 이미지의 크기를 줄일 수 있음
- 반드시 필요한 실행파일만 최종 이미지 결과물에 포함 시킴으로써 효과를 보는 것

### 기타 명령어

- ENV
    - 환경변수를 지정
    - Dockerfile뿐만 아니라 이미지에도 저장되므로 빌드된 이미지로 컨테이너를 생성하면 이 환경변수를 사용할 수 있다.
- VOLUME
    - 빌드된 이미지로 컨테이너를 생성했을 때 호스트와 공유할 컨테이너 내부의 디렉터리를 설정
    - 배열 형식으로도 사용할 수 있음
- ARG
    - build 명령어를 실행할 때 추가로 입력을 받아 Dockerfile 내에서 사용될 변수의 값을 설정함
    - 명령어 내에서 입력 시 key,value 쌍을 이뤄야함
- USER
    - 컨테이너에서 사용될 사용자 계정의 이름이나 UID를 설정하면 그 아래 명령어는 해당 사용자 권한으로 실행됨
    - 일반적으로 RUN으로 사용자 그룹과 계정을 생성한 뒤 사용함
    - 루트 권한이 필요하지 않다면 USER 사용 권장
    - 기본적으로 컨테이너 내부에서는 root 사용자를 사용하도록 설정된다. 이는 컨테이너가 호스트의 root 권한을 가질 수 있다는 것을 의미하기 때문에 보안 측면에서 바람직하지 않다. 예를 들어 root가 소유한 호스트의 디렉터리를 컨테이너에 공유했을 때, 컨테이너 내부에서는 공유된 root 소유의 디렉터리를 마음대로 조작할 수 있게 된다.
    때문에 컨테이너를 최종 배포할 때는 컨테이너 내부에서 새로운 사용자를 생성해 사용하는 것을 권장한다.
- COPY
    - 로컬 디렉터리에서 읽어 들인 컨텍스트로부터 이미지에 파일을 복사 (경로는 build가 시작된 경로에서 시작)
    - 형식은 ADD와 동일함
    - COPY는 로컬 파일만 이미지에 추가할 수 있지만 ADD는 외부 url 가능
    - ADD는 url이나 tar 파일을 추가하기 때문에 어떤 파일이 추가될지 빌드 시점에서 알 수 없지만,
    COPY는 로컬 컨텍스트로 부터 직접 추가하기 때문에 명확하게 확인할 수 있기 때문에 권장
- ENTRYPOINT, CMD
    - 차이점
        - entrypoint는 커맨드를 인자로 받아 사용할 수 있는 스크립트의 역할을 할 수 있다.
        - entrypoint가 설정되지 않았다면, cmd에 설정된 명령어를 그대로 실행하지만, 설정되었다면 cmd는 entrypoint의 인자가 된다.
        - 하나의 명령어만 입력해도 되지만, 일반적으로 스크립트 파일을 entrypoint의 인자로 넣어, 컨테이너가 시작될 때 마다 해당 스크립트를 실행하도록 구성한다. 스크립트 파일의 이름을 인자로 입력하면됨. 단, 스크립트 파일이 컨테이너 내부에 존재해야함.
        - CMD 또는 ENTRYPOINT에 설정하려는 명령어를 /bin/sh로 사용할 수 없다면 JSON 배열 형태로 설정해야함. 그러지 않으면 실제로 이미지를 생성할 때 두 명령어 앞에 /bin/sh -c 가 추가됨

### Dockerfile로 빌드 시 주의점

- 아무렇게나 작성하면 저장 공간을 불필요하게 차지하는 이미지나 레이어가 너무 많은 이미지가 생성될 수 있음
    - RUN 명령어를 하나로 묶어 이미지 레이어의 개수를 줄임

# 도커 데몬

### 도커 명령어 입력시

1. 사용자가 docker ~ 명령어 입력
2. /usr/bin/docker 는 /var/run/docker.sock 유닉스 소켓을 사용해 도커 데몬에게 명령어 전달
3. 도커 데몬은 이 명령어를 파싱하고 해당 작업을 수행
4. 수행 결과를 도커 클라이언트에게 반환하고 사용자에게 결과 출력

## 스프링 프로젝트 빌드

1. 해당 폴더에서 ./gradlew build
2. 빌드된 파일(jar)는 build 폴더의 libs 폴더에서 확인 가능
3. jar 파일은 java -jar 빌드파일명.jar 명령어로 실행

# 오늘 느낀점

---

- 새로운 기술을 알아가는건 진짜 재밌는데.. 이론대로 적용이 안될때 정말 너무 답답하다 ㅠ 시간은 오래 걸릴지라도 그 과정에서 배우는 점도 많고, 스스로 체득하면서 오래 기억할 수 있기 때문에 유익한 시간이라고 생각한다! 오늘도 재밌게 공부했다 ^~^

# 내일 목표

---

- 1박2일 가족여행! 차에서 공부는 하겠지만 아마 TIL은 쉬어갈 것 같다.
- 알고리즘 문제풀이